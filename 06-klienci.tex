\chapter{Aplikacje klienckie}

Na podstawie analizy statystyk dotyczących podziału rynku aplikacji na platformy\cite{stats}, zdecydowano się na stworzenie 3 klientów systemu The Guard, które pozwolę możliwie największej grupie osób na korzystanie z systemu:
\begin{itemize}
\item aplikacja mobilna na system Android,
\item aplikacja mobilna na system iOS,
\item aplikacja internetowa.
\end{itemize}

\section{Funkcje aplikacji}
\paragraph{Logowanie}
Do prawidłowego przejścia do ekranu głównego aplikacji niezbędne jest posiadanie konta. Po rejestracji użytkownika lub po pomyślnym uwierzytelnieniu jeśli konto zostało już wcześniej założone następuje pobranie wszystkich danych użytkownika, jego podłączonych urządzeń i przejście do głównego panelu z dostępem do wszystkich niżej omówionych funkcji.
\nopagebreak
\begin{figure}[H]
   \centering
   \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Logowanie.png}}
   \hfill
   \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/login.png}}
   \hfill
   \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/login.png}}
   \caption{Widok logowania [źródło własne]}
   \label{fig:logowanie}
\end{figure}

\paragraph{Monitoring}
Aplikacja pobiera i wyświetla obraz na żywo z zaznaczonego urządzenia podłączonego do konto użytkownika.
\nopagebreak
\begin{figure}[H]
    \centering
    \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Monitoring.png}}
    \hfill
    \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/liveStreamiOS.png}}
    \hfill
    \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/rasp_view.png}}
    \caption{Widok monitoringui [źródło własne]}
    \label{fig:monitoring}
\end{figure}

\paragraph{Status czujników}
Po przejściu do tej sekcji użytkownik otrzymuje bieżące dane z wszystkich czujników z zaznaczonego urządzenia. Na podstawie koloru prezentowanej wartości z czujnika użytkownik może analizować zagrożenie. Kolor zielony reprezentuje bezpieczne odczyty na czujnikach, kolor pomarańczowy średnie, kolor czerwony natomiast oznacza bardzo wysoki poziom niebezpieczeństwa.
\nopagebreak
\begin{figure}[H]
    \centering
    \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Czujniki.png}}
    \hfill
    \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/sensors.png}}
    \hfill
    \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/rasp_view.png}}
    \caption{Widok czujnikówi [źródło własne] }
    \label{fig:czujniki}
\end{figure}

\paragraph{Dziennik zdarzeń}
W tej sekcji użytkownik ma dostęp do historii zdarzeń w systemie.
\nopagebreak
\begin{figure}[H]
    \centering
    \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Zdarzenia.png}}
    \hfill
    \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/history.png}}
    \hfill
    \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/rasp_notifications.png}}
    \caption{Widok zdarzeń [źródło własne] }
    \label{fig:zdarzenia}
\end{figure}

\paragraph{Ostatnie zagrożenia}
Prezentacja ostatniego nagranego zagrożenia. Służy do szybkiego przeglądu ostatniego niebezpieczeństwa i prezentuje ostatni nagrany materiał video.
\nopagebreak
\begin{figure}[H]
    \centering
    \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Zagrozenia.png}}
    \hfill
    \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/dangeriOS.png}}
    \hfill
    \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/rasp_notifications.png}}
	\caption{Widok zagrożeń [źródło własne]}
    \label{fig:zagrozenia}
\end{figure}
\pagebreak

\paragraph{Ustawienia urządzenia}
Użytkownik ma możliwość zmiany nazwy urządzenia, które zazwyczaj reprezentuje miejsce, w którym się znajduje. Istnieje również możliwość uzbrojenia i wyłączenia każdego urządzenia. Sprowadza się to do tego, że w przypadku zaznaczenia opcji "Disarmed"  użytkownik nie otrzyma kolejnych notyfikacji o zagrożeniach. Opcja ta może okazać się przydatna w momencie uszkodzenia któregoś z modułów i tym samym błędnych danych wysyłanych z czujników.
\nopagebreak
\begin{figure}[H]
    \centering
    \subfloat[Aplikacja Android]{\includegraphics[height=5cm]{android-screenshots/Ustawienia.png}}
    \hfill
    \subfloat[Aplikacja iOS]{\includegraphics[height=5cm]{ios_screenshots/settings.png}}
    \hfill
    \subfloat[Aplikacja internetowa]{\includegraphics[height=4cm]{web_screenshots/rasp_rename.png}}
    \caption{Widok ustawień [źródło własne] }
    \label{fig:ustawienia}
\end{figure}

\section{Aplikacja Android}
\paragraph{Wybór narzędzi} Do stworzenia aplikacji mobilnej na system Android użyto języka Kotlin - języka stworzonego przez firmę JetBrains, który 17 maja 2017 roku został uznany przez Google jako oficjalny język programowania aplikacji na platformę Android.\footnote{\url{https://twitter.com/Android/status/864911929143197696}}
Kotlin ściśle współegzystuje z kodem stworzonym w Javie i w przypadku Androida jest kompilowany do kodu JVM.\cite{KOTLIN}

Skorzystano ze środowiska Android Studio w wersji 3.0.1, do automatyzacji budowy projektu został wykrozystany Gradle w wersji 4.1.

Aplikacja skierowana jest na urządzenia z systemem Android od wersji Lollipop 5.0 (o numerze SDK większym niż 20), który został wydany 12.12.2014 r. Ograniczenie wersji spowodowane jest możliwością użycia bardziej zaawansowanych komponentów, niedostępnych dla niższych wersji. W styczniu 2018 r. oficjalne statystyki informują o tym, że około 80,7 \% wszystkich urządzeń z systemem Android na świecie ma wersję 5.0 lub wyższą. \cite{android}

\paragraph{Architektura} Aplikacja The Guard dla systemu Android została stworzona zgodnie z założeniami architektury Model View Presenter.
Architektura MVP zakłada rozdzielenie kodu źródłowego aplikacji na 3 kategorie:
\begin{itemize}
\item Model - kod odpowiedzialny za logikę biznesową, połączenie z serwerem i złożone operacje biznesowe,
\item View - kod odpowiedzialny wyłącznie za poprawne wyświetlanie przygotowanych informacji,
\item Presenter - kod odpowiedzialny za przygotowanie informacji otrzymanych z warstwy model do wyświetlenia w warstwie View.
\end{itemize}
Największą zaletą architektury MVP jest możliwość wygodnego testowania logiki aplikacji (w warstwie Presenter) oraz zastosowanie programowania reaktywnego przy użyciu biblioteki RxKotlin.
Warstwy komunikują się między sobą w sposób reaktywny - przy użyciu strumieni wydarzeń.
Przykładowo klasa warstwy Presenter odpowiedzialna za wyświetlanie obrazu z kamery wykorzystuje klasę warstwy Model do asynchronicznej komunikacji z API.\cite{RXJAVA}

\begin{figure}[H]
    \centering
    \includegraphics[width=9cm]{android-mvp.png}
    \caption{Struktura MVP [źródło własne]}
\end{figure}

\paragraph{Interfejs użytkownika} Aplikacja została zaprojektowana zgodnie z wytycznymi Material Design. \cite{MDESIGN}
Do nawigacji po funkcjach aplikacji służy panel na dole ekranu - "Bottom Bar".
Zanim będzie on widoczny, użytkownik musi najpierw zalogować się (lub zarejestrować) przy użyciu adresu email oraz hasła.

\paragraph{Wykorzystane biblioteki}
\begin{itemize}
    \item \textbf{com.squareup.retrofit2} - biblioteka służąca do wygodnej komunikacji z API
    \item \textbf{io.reactivex:rxandroid} - biblioteka zapewniająca \textit{Scheduler} platformy Android dla kodu reaktywnego,
    \item \textbf{com.jakewharton.rxbinding} - biblioteka zapewniająca nakładki na widoki Androida generujące zdarzenia dla programowania reaktywnego,
    \item \textbf{com.github.zurche:plain-pie} - biblioteka wyświetlająca diagramy na podstawie danych z czujników,
    \item \textbf{com.github.jacek-marchwicki.recyclerview-changes-detector} - biblioteka umożliwiająca automatyczną zmianę widoków po detekcji zmiany zbioru wyświetlanych danych,
    \item \textbf{com.google.code.gson} - biblioteka umożliwiająca serializacje i deserializacje obiektów
    \item \textbf{com.google.firebase} - biblioteki służące do obsługi usług Firebase
\end{itemize}

\paragraph{Programowanie reaktywne} Aktualizacja danych z czujników, obsługa interfejsu użytkownika, zapytania API oraz komunikacja z usługami Firebase zrealizowane są zgodnie z paradygmatami programowania reaktywnego.
\textit{Observables} tworzą zdarzenia, które mogą zostać modyfikowane przez liczne operatory, a następnie powodować reakcje, które zostały do nich \textit{zasubskrybowane}.

\section{Aplikacja iOS}
Aplikacja przeznaczona jest na urządzenia z systemem operacyjnym iOS od wersji 10.0. 
Nie wspiera ona wcześniejszych wersji ze względu na nowe funkcje, które Apple wprowadziło wraz z pojawieniem się iOS 10.0 (m.in. klasa UNUserNotificationCenter). Jednak 93\% wszystkich obecnych użytkowników tego systemu(rys. 5.1) jest w stanie zainstalować oprogramowanie a liczba ta stale rośnie. Aplikacja wspiera zarówno telefony komórkowe iPhone jak i tablety iPad. 
\begin{figure}[H]
	\centering
	\includegraphics[width=4cm]{ios_screenshots/iOSstat.png}
	\caption{Udziały wersji systemu iOS z 18.01.2018 \protect\cite{iosversions}}
\end{figure}
Napisana w stosunkowo nowym języku Swift (zaprezentowany przez Apple w 2014 roku) w oparciu o architekturę MVC (Model-View-Controller) wykorzystując przy tym programowanie reaktywne i funkcjonalne. Aplikacja powstała w programie Xcode. Programowanie reaktywne zrealizowano przy pomocy biblioteki RxSwift. Ten paradygmat programowania związany jest z pojęciem obserwatora i sekwencji obserwowalnych. Każdy obserwator wywołując funkcję 'subscribe' na elemencie obserwowalnym otrzymuje informację o każdej zmianie na tym obiekcie. RxSwift wykorzystano m.in w celu wznowienia streamu obrazu z kamery w momencie przejścia aplikacji z trybu pracy w tle do trybu aktywnego. Oznacza to, że po wyjściu z aplikacji i po ponownym jej uruchomieniu tracono obraz ze streamu. Przyczyną jest polityka Apple, która nie zaleca aby aplikacje pracowały w tle i domyślnie wyłącza każdą taką aktywność. Ma to na celu przedłużenie żywotności baterii i optymalizacji całego systemu poprzez ograniczenie ilości zajmowanych zasobów \cite{backgroundmodes}.  Oczywiście istnieje możliwość włączenia pracy w tle, jednakże konieczne jest aktywowanie trybu "Background Modes" i zaznaczenie konkretnej aktywności, którą chcielibyśmy wykonywać. Lista dozwolonych czynności możliwych do realizacji jest jednak ograniczona (rys. 5.2). 
\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{ios_screenshots/backgroundModes.png}
	\caption{Tryby pracy w tle [źródło własne]}
\end{figure}
Próba oszustwa i wykonywania innej pracy w tle niż zaznaczona zostanie wychwycona w procesie weryfikacji przed jej publikacją na platformie Apple Store. Dzięki programowaniu reaktywnemu problem wznowienia podglądu obrazu został rozwiązany co prezentuje poniższy kod:
\begin{verbatim}
let appDelegate = UIApplication.shared.delegate as! AppDelegate
        appDelegate.inBackground.asObservable().subscribe(onNext: { (value) in
            if let streamView = self.streamView {
                if let player = self.currentPlayer {
                    if value == false {
                        self.streamVideoFrom(urlString: self.currentUrlString!)
                        print("Enter foreground")
                    } else {
                        print("Enter background")
                        streamView.layer.sublayers?.forEach({ (layer) in
                            layer.removeFromSuperlayer()
                        })
                    }
                }
            }
        }).disposed(by: disposeBag)
\end{verbatim}
Zmienna 'inBackground', która jest zmienną obserwowalną, ustawiana jest w oddzielnej klasie AppDelegate (klasa, która zapewnie poprawną interakcję z systemem iOS) na wartość true w chwili przejścia do trybu pracy w tle i na wartość false w przeciwnym wypadku. Klasa, w której wywoływany jest funkcja 'subscribe' jest obserwatorem tej zmiennej. Kod wewnątrz funkcji subscribe uruchamiany jest przy każdej zmianie wartości 'inBackground' i wznawia ponownie stream po każdym ponownym uruchomieniu programu.
"Programowanie funkcjonalne natomiast polega na traktowaniu funkcji jako obiektu. Oznacza to, że mogą być one zapisywane, kopiowane i przekazywane tak samo jak wszystkie inne obiekty. Mogą być używane jako parametry innych funkcji." \cite[p.~172]{proswift}. Wykorzystane są w miejscach gdzie konieczne jest przekształcanie danych:
\begin{verbatim}
lastNotification = notifications.array.sorted(by: { (n1, n2) -> Bool in
	n1.date > n2.date 
}).filter({ (notif) -> Bool in return notif.type == "PIRSensor"}).first
\end{verbatim}
Na tablicy z notyfikacjami zastosowano szereg kolejnych funkcji: posortowano je malejąco według daty, przefiltrowano w taki sposób aby wybrać tylko te o typie 'PIRSensor' czyli te pochodzące z czujnika ruchu. Na sam koniec wybrano tylko jeden pierwszy element z wybranych i wynik wpisano do zmiennej lastNotification. Każda kolejna wywoływana funkcja np. filter, odbiera wynik poprzedniej. 

Strukturę kodu (rys. \ref{iosversion}) podzielono na kilka osobnych, logicznych części. Folder Firebase zawiera model bazy danych czujników, które zapisane są na serwerach Firebase. W folderze GuardManager znajdują się elementy odpowiedzialne za komunikację REST-ową z serwerem Django i modele bazy danych znajdującej się na naszym serwerze. Folder Views jest zbiorem widoków, które wczytywane są w zależności, w której sekcji się znajdujemy (opis sekcji niżej). ViewController.swift jest głównym kontrolerem zarządzającym widokami i modelami. Odpowiada za załadowanie odpowiedniego widoku i prezentację danych z odpowiedniej sekcji. W folderze GuardianAppTests napisane zostały testy jednostkowe, które sprawdzają poprawność przekształcania danych typu JSON (odpowiedź serwera) do obiektów zdefiniowanych w folderze GuardManager/Models. Klasy, których nazwy kończą się na Manager oznaczają obiekty typu Singleton. Celem takiego wzorca jest zapewnienie istnienia tylko jednej instancji w całej aplikacji i globalnego dostępu do tego obiektu. GuardManager, który odpowiada za pobieranie danych z bazy danych - taki obiekt nie powinien być utworzony więcej niż jeden raz, gdyż wszystkie klasy, które z niego korzystają nie potrzebują kolejnych instancji tej klasy. W ten sposób zapewniono, że zawsze odwołujemy się do tego samego obiektu.
\begin{figure}[H]
	\centering
	\includegraphics[width=4cm]{ios_screenshots/iOSstructure.png}
	\caption{Struktura aplikacji [źródło własne]}
	\label{iosversion}
\end{figure}
Instalacja zewnętrznych bibliotek odbywa się za pomocą CocoaPods. Jest to menadżer zależności dzięki któremu szybko możemy wyszukać i zainstalować wymagane oprogramowanie. Wszystkie użyte zależności przedstawiono poniżej: 
\begin{verbatim}
  pod 'Moya'
  pod 'MBProgressHUD', '~> 1.0'
  pod 'RxSwift',    '~> 4.0'
  pod 'RxCocoa',    '~> 4.0'
  pod 'IHKeyboardAvoiding'
  pod 'Moya-SwiftyJSONMapper'
  pod 'Firebase/Core'
  pod 'Firebase/Messaging'
  pod 'Firebase/Auth'
  pod 'Firebase/Database'
  pod 'M13ProgressSuite'
\end{verbatim}
Moya używana jest do asynchronicznej REST-owej komunikacji z serwerem Django. SwiftyJSONMapper przydatna okazuje się do przekształcenia odpowiedzi serwera w postaci JSON do wcześniej zdefiniowanego modelu. MBProgressHUD umożliwia wyświetlanie ekranu ładowania podczas pobierania informacji z serwera. RxSwift i RxCocoa to biblioteki do programowania reaktywnego. Moduły Firebase itp. służą do komunikacji z serwerami Firebase. Ostatni 'pod M13ProgressSuite' wykorzystano do rysowania wykresów i animowanych elementów graficznych w systemie iOS.
Po uruchomieniu aplikacji pierwszym widokiem jest ekran logowania i rejestracji użytkowników (rys 6.1b). 
Po prawidłowym uwierzytelnieniu użytkownika uzyskiwany jest dostęp do głównego widoku aplikacji. W górnej części możliwy jest wybór 5 sekcji:
sekcja czujników, sekcja historii notyfikacji, sekcja ostatnich zagrożeń przy wykryciu ruchu, sekcja monitoringu na żywo, sekcja ustawień. Wszystkie te sekcje dotyczą konkretnego urządzenia wybranego na pasku u dołu ekranu. Funkcje każdej z nich zostały opisane w rozdziale 6.1, tutaj zostaną zaprezentowane jedynie szczegóły implementacyjne i zrzuty ekranów z wersji na iOS. Przy pierwszym uruchomieniu nie istnieje żadne urządzenie przypisane do naszego konta użytkownika. Aby dodać pierwsze i kolejne stacje, od których chcemy otrzymywać notyfikacje o zagrożeniach a także śledzić i monitorować informacje z czujników należy wybrać przycisk "New" z plusikiem w dolnej części ekranu. Pojawi się okno z prośbą o wpisanie numeru identyfikującego urządzenie. Po chwili dodany 'Guard' będzie widoczny w na liście.


\paragraph{Sekcja czujników:}
Jest to jedna z najważniejszych sekcji aplikacji (rys 6.3b).  Otrzymuje ona dane z czujników w czasie rzeczywistym i prezentuje je użytkownikowi. Implementacja funkcjonalności prezentowania zagrożenia na konkretnym czujniku przy użyciu kolorów zrealizowana została przy pomocy modelu HSV, który w przeciwieństwie do RGB pozwala na bardzo proste przejście z jednego koloru do kolejnego poprzez zmienę tylko jednego parametru. Zmieniając parametr Hue zmieniamy barwę przy stałym nasyceniu i jasności. Wartość tego parametru równa 120\textdegree{} odpowiada kolorowi zielonemu, kolor czerwony to 0\textdegree{}. Przekształcając wartość otrzymaną z czujników, która jest z zakresu [0-1] na wartość z przedziału [120-0] otrzymano wspomniany efekt. 
Poniżej przedstawiono fragment konwersji danych z czujników na kolor w modelu HSV, gdzie zmienna sensors[0] reprezentuje czujnik LPG.
\begin{verbatim}
UIColor(hue: CGFloat(0.33 - (sensors[0].value * 0.33)),
saturation: 1, brightness: 1, alpha: 1)
\end{verbatim}


\paragraph{Sekcja historii notyfikacji:}
Po zaznaczeniu daty reprezentującej moment wystąpienia zagrożenia i wybraniu przycisku 'preview' prezentowana jest informacja o miejscu niebezpieczeństwa i jego rodzaju. (rys 6.4b).


\paragraph{Sekcja monitoringu:}
Sekcja odpowiedzialna za prawidłowy odbiór obrazu z kamery zaznaczonej w dolnej części ekranu(rys. 6.2b). Okno, w którym odbywa się transmisja ustawiono w taki sposób, aby bez względu na rozmiar telefonu utrzymywało proporcję 16:9. Pozbyto się dzięki temu czarnych ramek lub braku części transmitowanego obrazu. W tym samym oknie prezentowane są nagrane materiały filmowe z historii zdarzeń, które zakrywają obraz nadawany na żywo. Przejście do tej sekcji wznawia pobieranie obrazu z urządzeń w czasie rzeczywistym.


Przeprowadzono kilka testów aplikacji pod pełnym obciążeniem za pomocą programu Instruments. Szczególnie interesująco przedstawia się zużycie sieci podczas streamu obrazu. Widać, że w ciągu jednej minuty pobrano 6,61MB a wysłano jedynie 24,11Kb (rys. \ref{netuse}). Obraz pobierany jest tylko wtedy kiedy aplikacja jest aktywna. W ciągu godziny działania aplikacji pobierze ona około 400MB danych. Jednak dla zapewnienia komfortu użytkowania i płynnego streamu obrazu zalecane jest posiadanie łącza umożliwiającego transfer danych na poziomie min. 200KB/s. 
\begin{figure}[H]
	\centering
	\includegraphics[width=11cm]{ios_screenshots/networkUsage.png}
	\caption{Zużycie sieci podczas transmisji obrazu [źródło własne]}
	\label{netuse}
\end{figure}
Przeprowadzono także test na zużycie pamięci RAM i zużycie procesora. Te jednak są niewielkie i wynoszą odpowiednio 25MB pamięci RAM i średnio 1 procent zużycia procesora.
Zużycie procesora wzrasta do poziomu ok. 15 procent tylko w momencie pobierania nagranego obrazu z serwera. Wtedy też zużycie pamięci RAM jest o około 5MB większe i wynosi około 30MB (rys. \ref{cpuram}).
\begin{figure}[H]
	\centering 
	\includegraphics[width=11cm]{ios_screenshots/CPURAM.png}
	\caption{Zużycie procesora i pamięci RAM przy największym obciążeniu [źródło własne]}
	\label{cpuram}
\end{figure}
Testy przeprowadzono na iPhonie 6S i iPadzie Pro.


\section{Aplikacja internetowa}
Aplikacja internetowa przeznaczona jest dla użytkowników wszystkich systemów operacyjnych i~została przetestowana w~przeglądarce Firefox. Rozmieszczenie komponentów aplikacji różni się od tego zastosowanego w~aplikacjach IOS oraz Android - spowodowane jest to inną rozdzielczością ekranu. 

\paragraph{Struktura projektu} przedstawiona jest na rysunku \ref{web_struct}. Folder migrations zawiera pliki tworzone automatycznie przez bibliotekę Django. W folderze templates stworzone są szablony plików html specyficzne dla danych widoków aplikacji. Na uwagę zasługują także pliki urls.py oraz views.py. W~pierwszym znajdują się adresy url używane przez aplikację oraz informacja nt. jaki widok powinien być wyrenderowany dla użytkownika w~momencie otwarcia przez niego w przeglądarce danego linku. W pliku views.py znajdują się funkcje odpowiedzialne za renderowanie widoków aplikacji oraz łączenie z bazami danych. 
\begin{figure}[H]
	\centering
	\includegraphics[width=5cm]{web_screenshots/web_struct.png}
	\caption{Struktura projektu aplikacji internetowej\newline[źródło własne]}
	\label{web_struct}
\end{figure}

\paragraph{Implementacja Django - połączenie z bazą danych:}
Biblioteka Django posiada wbudowane rozwiązania umożliwiające pobieranie informacji z bazy danych projektu dzięki czemu aplikacja internetowa nie wysyła zapytań na określone dla aplikacji mobilnych porty, tylko komunikuje się bezpośrednio z bazą danych. Rozwiązanie to umożliwia uniezależnienie aplikacji internetowej od stanu portów oraz zmniejsza liczbę potrzebnych zapytań wysyłanych do serwera.
Aplikacja internetowa przeznaczona jest dla użytkowników wszystkich systemów operacyjnych i~została przetestowana w~przeglądarce Firefox w systemach operacyjnych Microsoft Windows 10 (Firefox 58.0.1) oraz Linux Debian 9 (Firefox ESR 52.5.2 64 bit). Do stworzenia aplikacji użyto języków programowania Python 3, JavaScript oraz framework'u Django, natomiast frontend jest oparty na bibliotece Bootstrap oraz JQuery. Połączenie z~bazą danych Firebase zaimplementowano za pomocą Firebase Web Api. Rozmieszczenie komponentów aplikacji różni się od tego zastosowanego w~aplikacjach IOS oraz Android - spowodowane jest to inną rozdzielczością ekranu. 

\paragraph{Panel logowania / rejestracji użytkownika:} Panele logowania oraz rejestracji użytkownika są do siebie bardzo podobne - jedyna ich różnica jest w nazwie i~funkcjonalności. Obydwa panele składają się z~loga aplikacji oraz formularza w~którym trzeba podać adres email i~hasło. W przypadku panelu logowania, dane są weryfikowane i~jeśli są poprawne użytkownik zostaje zalogowany. Jeżeli użytkownik chce zarejestrować konto, sprawdzana jest poprawność adresu email, a następnie tworzone jest konto w usłudze FireBase Auth. W przypadku błędu, jest on wyświetlany powyżej formularza (rys. \ref{web_login_err})
\begin{figure}[H]
	\centering
	\includegraphics[width=11cm]{web_screenshots/error.png}
	\caption{Widok logowania z przykładowym błędem w~aplikacji internetowej\newline[źródło własne]}
	\label{web_login_err}
\end{figure}

\paragraph{Menu wyboru urządzenia:} Po prawidłowym zalogowaniu do aplikacji, użytkownik może zobaczyć listę swoich urządzeń, dodać nowe oraz zaczyna dostawać powiadomienia w razie wykrytego zagrożenia. W~przypadku kliknięcia przycisku `Connect rasp', użykownik zostaje przekierowany do widoku umożliwiającego rejestrację nowego urządzenia. Po wprowadzeniu numeru seryjnego urządzenia oraz jego nazwy, zostaje dodany do baz danych. Po wybraniu urządzenia, informacje nt. jego stanu będą wyświetlane po prawej stronie okna, która w momencie zalogowania jest pusta. Urządzenia w~menu są rozpoznawane na podstawie ich nazw. 

\paragraph{Widok konkretnego urządzenia:} Po wybraniu z~menu kokretnego urządzenia, użytkownik zostaje przekierowany na stronę pojedyńczego urządzenia (rys. \ref{fig:monitoring}). Pod nazwą urządzenia i~jego numerem seryjnym wyświetlany jest aktualny obraz z kamery oraz stan czujników. Dzięki zastosowaniu nasłuchiwania na bazie danych Firebase, zmiany są na bieżąco wyświetlane na stronie. Użytkownik ma możliwość po naciśnięciu odpowiedniego przycisku:
\begin{itemize}
\item Zmienić nazwę urządzenia - po kliknięciu na przycisk rename znajdujący się obok nazwy urządzenia, użytkownik zostanie przekierowany do panelu zmiany nazwy (rys. \ref{fig:ustawienia}).
\item Wyłączyć / włączyć alerty 
\item Zobaczyć notyfikacje danego urządzenia - poprzez klknięcie na przycisk `Check notifications from this device', użytkownik zostanie przekierowany do widoku listy notyfikacji danego urządzenia (rys. \ref{fig:zdarzenia}).
\end{itemize}

\paragraph{Wyświetlanie notyfikacji:} W każdym z widoków aplikacji internetowej w czasie rzeczywistym sprawdzane są notyfikacje z bazy danych z pomocą Firebase WebApi. W przypadku wykrycia zmiany uznawanej za niebezpieczną za pomocą skryptów przeglądarki (JavaScript + JQuery) wyświetlany jest monit informujący o niebezpiecznym zdarzeniu, co pokazane jest na rysunku \ref{web_notification}.  

\begin{figure}[H]
	\centering
        \captionsetup{justification=centering, margin=1cm}
	\includegraphics[width=11cm]{web_screenshots/danger.png}
	\caption{Informacja o~niebezpiecznym zdarzeniu -~nagłej zmianie wartości odczytanej przez czujnik [źródło własne]}
	\label{web_notification}
\end{figure}
